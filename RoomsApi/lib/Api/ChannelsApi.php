<?php
/**
 * ChannelsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  RocketChatRoomsApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Rooms
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace RocketChatRoomsApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use RocketChatRoomsApi\ApiException;
use RocketChatRoomsApi\Configuration;
use RocketChatRoomsApi\HeaderSelector;
use RocketChatRoomsApi\ObjectSerializer;

/**
 * ChannelsApi Class Doc Comment
 *
 * @category Class
 * @package  RocketChatRoomsApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ChannelsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'getApiV1ChannelsAnonymousread' => [
            'application/json',
        ],
        'getApiV1ChannelsCounters' => [
            'application/json',
        ],
        'getApiV1ChannelsFiles' => [
            'application/json',
        ],
        'getApiV1ChannelsGetAllUserMentionsByChannel' => [
            'application/json',
        ],
        'getApiV1ChannelsGetIntegrations' => [
            'application/json',
        ],
        'getApiV1ChannelsHistory' => [
            'application/json',
        ],
        'getApiV1ChannelsInfo' => [
            'application/json',
        ],
        'getApiV1ChannelsList' => [
            'application/json',
        ],
        'getApiV1ChannelsListJoined' => [
            'application/json',
        ],
        'getApiV1ChannelsMembers' => [
            'application/json',
        ],
        'getApiV1ChannelsMessages' => [
            'application/json',
        ],
        'getApiV1ChannelsModerators' => [
            'application/json',
        ],
        'getApiV1ChannelsOnline' => [
            'application/json',
        ],
        'getApiV1ChannelsRoles' => [
            'application/json',
        ],
        'getChannelsMembersByHighestRole' => [
            'application/json',
        ],
        'posApiV1ChannelsRename' => [
            'application/json',
        ],
        'postApiV1ChannelsAddAll' => [
            'application/json',
        ],
        'postApiV1ChannelsAddLeader' => [
            'application/json',
        ],
        'postApiV1ChannelsAddModerator' => [
            'application/json',
        ],
        'postApiV1ChannelsAddOwner' => [
            'application/json',
        ],
        'postApiV1ChannelsArchive' => [
            'application/json',
        ],
        'postApiV1ChannelsClose' => [
            'application/json',
        ],
        'postApiV1ChannelsConvertToTeam' => [
            'application/json',
        ],
        'postApiV1ChannelsCreate' => [
            'application/json',
        ],
        'postApiV1ChannelsDelete' => [
            'application/json',
        ],
        'postApiV1ChannelsInvite' => [
            'application/json',
        ],
        'postApiV1ChannelsJoin' => [
            'application/json',
        ],
        'postApiV1ChannelsKick' => [
            'application/json',
        ],
        'postApiV1ChannelsLeave' => [
            'application/json',
        ],
        'postApiV1ChannelsOpen' => [
            'application/json',
        ],
        'postApiV1ChannelsRemoveLeader' => [
            'application/json',
        ],
        'postApiV1ChannelsRemoveModerator' => [
            'application/json',
        ],
        'postApiV1ChannelsRemoveOwner' => [
            'application/json',
        ],
        'postApiV1ChannelsSetAnnouncement' => [
            'application/json',
        ],
        'postApiV1ChannelsSetCustomFields' => [
            'application/json',
        ],
        'postApiV1ChannelsSetDefault' => [
            'application/json',
        ],
        'postApiV1ChannelsSetDescription' => [
            'application/json',
        ],
        'postApiV1ChannelsSetJoinCode' => [
            'application/json',
        ],
        'postApiV1ChannelsSetPurpose' => [
            'application/json',
        ],
        'postApiV1ChannelsSetReadOnly' => [
            'application/json',
        ],
        'postApiV1ChannelsSetTopic' => [
            'application/json',
        ],
        'postApiV1ChannelsSetType' => [
            'application/json',
        ],
        'postApiV1ChannelsUnarchive' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getApiV1ChannelsAnonymousread
     *
     * Read Channel Messages Anonymously
     *
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsAnonymousread'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\GetApiV1ChannelsAnonymousread200Response
     */
    public function getApiV1ChannelsAnonymousread($room_id = null, $room_name = null, $offset = null, $count = null, $sort = null, $query = null, $fields = null, string $contentType = self::contentTypes['getApiV1ChannelsAnonymousread'][0])
    {
        list($response) = $this->getApiV1ChannelsAnonymousreadWithHttpInfo($room_id, $room_name, $offset, $count, $sort, $query, $fields, $contentType);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsAnonymousreadWithHttpInfo
     *
     * Read Channel Messages Anonymously
     *
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsAnonymousread'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\GetApiV1ChannelsAnonymousread200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsAnonymousreadWithHttpInfo($room_id = null, $room_name = null, $offset = null, $count = null, $sort = null, $query = null, $fields = null, string $contentType = self::contentTypes['getApiV1ChannelsAnonymousread'][0])
    {
        $request = $this->getApiV1ChannelsAnonymousreadRequest($room_id, $room_name, $offset, $count, $sort, $query, $fields, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsAnonymousread200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsAnonymousread200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\GetApiV1ChannelsAnonymousread200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsAnonymousread200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\GetApiV1ChannelsAnonymousread200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsAnonymousreadAsync
     *
     * Read Channel Messages Anonymously
     *
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsAnonymousread'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsAnonymousreadAsync($room_id = null, $room_name = null, $offset = null, $count = null, $sort = null, $query = null, $fields = null, string $contentType = self::contentTypes['getApiV1ChannelsAnonymousread'][0])
    {
        return $this->getApiV1ChannelsAnonymousreadAsyncWithHttpInfo($room_id, $room_name, $offset, $count, $sort, $query, $fields, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsAnonymousreadAsyncWithHttpInfo
     *
     * Read Channel Messages Anonymously
     *
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsAnonymousread'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsAnonymousreadAsyncWithHttpInfo($room_id = null, $room_name = null, $offset = null, $count = null, $sort = null, $query = null, $fields = null, string $contentType = self::contentTypes['getApiV1ChannelsAnonymousread'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsAnonymousread200Response';
        $request = $this->getApiV1ChannelsAnonymousreadRequest($room_id, $room_name, $offset, $count, $sort, $query, $fields, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsAnonymousread'
     *
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsAnonymousread'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApiV1ChannelsAnonymousreadRequest($room_id = null, $room_name = null, $offset = null, $count = null, $sort = null, $query = null, $fields = null, string $contentType = self::contentTypes['getApiV1ChannelsAnonymousread'][0])
    {









        $resourcePath = '/api/v1/channels.anonymousread';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_id,
            'roomId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_name,
            'roomName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsCounters
     *
     * Get Channel Counters
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $user_id The user ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsCounters'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\GetApiV1ChannelsCounters200Response
     */
    public function getApiV1ChannelsCounters($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $user_id = null, string $contentType = self::contentTypes['getApiV1ChannelsCounters'][0])
    {
        list($response) = $this->getApiV1ChannelsCountersWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsCountersWithHttpInfo
     *
     * Get Channel Counters
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $user_id The user ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsCounters'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\GetApiV1ChannelsCounters200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsCountersWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $user_id = null, string $contentType = self::contentTypes['getApiV1ChannelsCounters'][0])
    {
        $request = $this->getApiV1ChannelsCountersRequest($x_auth_token, $x_user_id, $room_id, $room_name, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsCounters200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsCounters200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\GetApiV1ChannelsCounters200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsCounters200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\GetApiV1ChannelsCounters200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsCountersAsync
     *
     * Get Channel Counters
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $user_id The user ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsCounters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsCountersAsync($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $user_id = null, string $contentType = self::contentTypes['getApiV1ChannelsCounters'][0])
    {
        return $this->getApiV1ChannelsCountersAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsCountersAsyncWithHttpInfo
     *
     * Get Channel Counters
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $user_id The user ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsCounters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsCountersAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $user_id = null, string $contentType = self::contentTypes['getApiV1ChannelsCounters'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsCounters200Response';
        $request = $this->getApiV1ChannelsCountersRequest($x_auth_token, $x_user_id, $room_id, $room_name, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsCounters'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $user_id The user ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsCounters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApiV1ChannelsCountersRequest($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $user_id = null, string $contentType = self::contentTypes['getApiV1ChannelsCounters'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsCounters'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsCounters'
            );
        }





        $resourcePath = '/api/v1/channels.counters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_id,
            'roomId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_name,
            'roomName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsFiles
     *
     * Get Channel Files
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsFiles'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\GetApiV1ChannelsFiles200Response
     */
    public function getApiV1ChannelsFiles($x_user_id, $x_auth_token, $room_id = null, $room_name = null, $fields = null, $query = null, $sort = null, $count = null, $offset = null, string $contentType = self::contentTypes['getApiV1ChannelsFiles'][0])
    {
        list($response) = $this->getApiV1ChannelsFilesWithHttpInfo($x_user_id, $x_auth_token, $room_id, $room_name, $fields, $query, $sort, $count, $offset, $contentType);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsFilesWithHttpInfo
     *
     * Get Channel Files
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsFiles'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\GetApiV1ChannelsFiles200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsFilesWithHttpInfo($x_user_id, $x_auth_token, $room_id = null, $room_name = null, $fields = null, $query = null, $sort = null, $count = null, $offset = null, string $contentType = self::contentTypes['getApiV1ChannelsFiles'][0])
    {
        $request = $this->getApiV1ChannelsFilesRequest($x_user_id, $x_auth_token, $room_id, $room_name, $fields, $query, $sort, $count, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsFiles200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsFiles200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\GetApiV1ChannelsFiles200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsFiles200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\GetApiV1ChannelsFiles200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsFilesAsync
     *
     * Get Channel Files
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsFilesAsync($x_user_id, $x_auth_token, $room_id = null, $room_name = null, $fields = null, $query = null, $sort = null, $count = null, $offset = null, string $contentType = self::contentTypes['getApiV1ChannelsFiles'][0])
    {
        return $this->getApiV1ChannelsFilesAsyncWithHttpInfo($x_user_id, $x_auth_token, $room_id, $room_name, $fields, $query, $sort, $count, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsFilesAsyncWithHttpInfo
     *
     * Get Channel Files
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsFilesAsyncWithHttpInfo($x_user_id, $x_auth_token, $room_id = null, $room_name = null, $fields = null, $query = null, $sort = null, $count = null, $offset = null, string $contentType = self::contentTypes['getApiV1ChannelsFiles'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsFiles200Response';
        $request = $this->getApiV1ChannelsFilesRequest($x_user_id, $x_auth_token, $room_id, $room_name, $fields, $query, $sort, $count, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsFiles'
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApiV1ChannelsFilesRequest($x_user_id, $x_auth_token, $room_id = null, $room_name = null, $fields = null, $query = null, $sort = null, $count = null, $offset = null, string $contentType = self::contentTypes['getApiV1ChannelsFiles'][0])
    {

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsFiles'
            );
        }

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsFiles'
            );
        }









        $resourcePath = '/api/v1/channels.files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_id,
            'roomId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_name,
            'roomName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsGetAllUserMentionsByChannel
     *
     * Get all user mentions in a channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsGetAllUserMentionsByChannel'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\GetApiV1ChannelsGetAllUserMentionsByChannel200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function getApiV1ChannelsGetAllUserMentionsByChannel($x_auth_token, $x_user_id, $room_id, $offset = null, $count = null, $sort = null, string $contentType = self::contentTypes['getApiV1ChannelsGetAllUserMentionsByChannel'][0])
    {
        list($response) = $this->getApiV1ChannelsGetAllUserMentionsByChannelWithHttpInfo($x_auth_token, $x_user_id, $room_id, $offset, $count, $sort, $contentType);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsGetAllUserMentionsByChannelWithHttpInfo
     *
     * Get all user mentions in a channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsGetAllUserMentionsByChannel'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\GetApiV1ChannelsGetAllUserMentionsByChannel200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsGetAllUserMentionsByChannelWithHttpInfo($x_auth_token, $x_user_id, $room_id, $offset = null, $count = null, $sort = null, string $contentType = self::contentTypes['getApiV1ChannelsGetAllUserMentionsByChannel'][0])
    {
        $request = $this->getApiV1ChannelsGetAllUserMentionsByChannelRequest($x_auth_token, $x_user_id, $room_id, $offset, $count, $sort, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsGetAllUserMentionsByChannel200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsGetAllUserMentionsByChannel200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\GetApiV1ChannelsGetAllUserMentionsByChannel200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsGetAllUserMentionsByChannel200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\GetApiV1ChannelsGetAllUserMentionsByChannel200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsGetAllUserMentionsByChannelAsync
     *
     * Get all user mentions in a channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsGetAllUserMentionsByChannel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsGetAllUserMentionsByChannelAsync($x_auth_token, $x_user_id, $room_id, $offset = null, $count = null, $sort = null, string $contentType = self::contentTypes['getApiV1ChannelsGetAllUserMentionsByChannel'][0])
    {
        return $this->getApiV1ChannelsGetAllUserMentionsByChannelAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $offset, $count, $sort, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsGetAllUserMentionsByChannelAsyncWithHttpInfo
     *
     * Get all user mentions in a channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsGetAllUserMentionsByChannel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsGetAllUserMentionsByChannelAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $offset = null, $count = null, $sort = null, string $contentType = self::contentTypes['getApiV1ChannelsGetAllUserMentionsByChannel'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsGetAllUserMentionsByChannel200Response';
        $request = $this->getApiV1ChannelsGetAllUserMentionsByChannelRequest($x_auth_token, $x_user_id, $room_id, $offset, $count, $sort, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsGetAllUserMentionsByChannel'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsGetAllUserMentionsByChannel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApiV1ChannelsGetAllUserMentionsByChannelRequest($x_auth_token, $x_user_id, $room_id, $offset = null, $count = null, $sort = null, string $contentType = self::contentTypes['getApiV1ChannelsGetAllUserMentionsByChannel'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsGetAllUserMentionsByChannel'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsGetAllUserMentionsByChannel'
            );
        }

        // verify the required parameter 'room_id' is set
        if ($room_id === null || (is_array($room_id) && count($room_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $room_id when calling getApiV1ChannelsGetAllUserMentionsByChannel'
            );
        }





        $resourcePath = '/api/v1/channels.getAllUserMentionsByChannel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_id,
            'roomId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsGetIntegrations
     *
     * Get Channel Integrations
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsGetIntegrations'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\GetApiV1ChannelsGetIntegrations200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function getApiV1ChannelsGetIntegrations($x_auth_token, $x_user_id, $room_id, $offset = null, $sort = null, $fields = null, $query = null, $count = null, string $contentType = self::contentTypes['getApiV1ChannelsGetIntegrations'][0])
    {
        list($response) = $this->getApiV1ChannelsGetIntegrationsWithHttpInfo($x_auth_token, $x_user_id, $room_id, $offset, $sort, $fields, $query, $count, $contentType);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsGetIntegrationsWithHttpInfo
     *
     * Get Channel Integrations
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsGetIntegrations'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\GetApiV1ChannelsGetIntegrations200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsGetIntegrationsWithHttpInfo($x_auth_token, $x_user_id, $room_id, $offset = null, $sort = null, $fields = null, $query = null, $count = null, string $contentType = self::contentTypes['getApiV1ChannelsGetIntegrations'][0])
    {
        $request = $this->getApiV1ChannelsGetIntegrationsRequest($x_auth_token, $x_user_id, $room_id, $offset, $sort, $fields, $query, $count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsGetIntegrations200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsGetIntegrations200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\GetApiV1ChannelsGetIntegrations200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsGetIntegrations200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\GetApiV1ChannelsGetIntegrations200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsGetIntegrationsAsync
     *
     * Get Channel Integrations
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsGetIntegrations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsGetIntegrationsAsync($x_auth_token, $x_user_id, $room_id, $offset = null, $sort = null, $fields = null, $query = null, $count = null, string $contentType = self::contentTypes['getApiV1ChannelsGetIntegrations'][0])
    {
        return $this->getApiV1ChannelsGetIntegrationsAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $offset, $sort, $fields, $query, $count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsGetIntegrationsAsyncWithHttpInfo
     *
     * Get Channel Integrations
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsGetIntegrations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsGetIntegrationsAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $offset = null, $sort = null, $fields = null, $query = null, $count = null, string $contentType = self::contentTypes['getApiV1ChannelsGetIntegrations'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsGetIntegrations200Response';
        $request = $this->getApiV1ChannelsGetIntegrationsRequest($x_auth_token, $x_user_id, $room_id, $offset, $sort, $fields, $query, $count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsGetIntegrations'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsGetIntegrations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApiV1ChannelsGetIntegrationsRequest($x_auth_token, $x_user_id, $room_id, $offset = null, $sort = null, $fields = null, $query = null, $count = null, string $contentType = self::contentTypes['getApiV1ChannelsGetIntegrations'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsGetIntegrations'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsGetIntegrations'
            );
        }

        // verify the required parameter 'room_id' is set
        if ($room_id === null || (is_array($room_id) && count($room_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $room_id when calling getApiV1ChannelsGetIntegrations'
            );
        }







        $resourcePath = '/api/v1/channels.getIntegrations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_id,
            'roomId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsHistory
     *
     * Get Channel History
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $latest The end of time range of messages to retrieve. The default value is the current date and time. (optional)
     * @param  string $oldest The start of the time range of messages to retrieve (optional)
     * @param  bool $inclusive Whether messages which land on the latest and oldest dates should be included. The default value is false. (optional)
     * @param  bool $show_thread_messages Whether thread messages should be included in the response (optional)
     * @param  bool $unreads Whether the number of unread messages should be included. The default value is false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsHistory'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\GetApiV1ChannelsFiles200Response
     */
    public function getApiV1ChannelsHistory($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $sort = null, $count = null, $offset = null, $latest = null, $oldest = null, $inclusive = null, $show_thread_messages = null, $unreads = null, string $contentType = self::contentTypes['getApiV1ChannelsHistory'][0])
    {
        list($response) = $this->getApiV1ChannelsHistoryWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name, $sort, $count, $offset, $latest, $oldest, $inclusive, $show_thread_messages, $unreads, $contentType);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsHistoryWithHttpInfo
     *
     * Get Channel History
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $latest The end of time range of messages to retrieve. The default value is the current date and time. (optional)
     * @param  string $oldest The start of the time range of messages to retrieve (optional)
     * @param  bool $inclusive Whether messages which land on the latest and oldest dates should be included. The default value is false. (optional)
     * @param  bool $show_thread_messages Whether thread messages should be included in the response (optional)
     * @param  bool $unreads Whether the number of unread messages should be included. The default value is false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsHistory'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\GetApiV1ChannelsFiles200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsHistoryWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $sort = null, $count = null, $offset = null, $latest = null, $oldest = null, $inclusive = null, $show_thread_messages = null, $unreads = null, string $contentType = self::contentTypes['getApiV1ChannelsHistory'][0])
    {
        $request = $this->getApiV1ChannelsHistoryRequest($x_auth_token, $x_user_id, $room_id, $room_name, $sort, $count, $offset, $latest, $oldest, $inclusive, $show_thread_messages, $unreads, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsFiles200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsFiles200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\GetApiV1ChannelsFiles200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsFiles200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\GetApiV1ChannelsFiles200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsHistoryAsync
     *
     * Get Channel History
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $latest The end of time range of messages to retrieve. The default value is the current date and time. (optional)
     * @param  string $oldest The start of the time range of messages to retrieve (optional)
     * @param  bool $inclusive Whether messages which land on the latest and oldest dates should be included. The default value is false. (optional)
     * @param  bool $show_thread_messages Whether thread messages should be included in the response (optional)
     * @param  bool $unreads Whether the number of unread messages should be included. The default value is false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsHistoryAsync($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $sort = null, $count = null, $offset = null, $latest = null, $oldest = null, $inclusive = null, $show_thread_messages = null, $unreads = null, string $contentType = self::contentTypes['getApiV1ChannelsHistory'][0])
    {
        return $this->getApiV1ChannelsHistoryAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name, $sort, $count, $offset, $latest, $oldest, $inclusive, $show_thread_messages, $unreads, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsHistoryAsyncWithHttpInfo
     *
     * Get Channel History
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $latest The end of time range of messages to retrieve. The default value is the current date and time. (optional)
     * @param  string $oldest The start of the time range of messages to retrieve (optional)
     * @param  bool $inclusive Whether messages which land on the latest and oldest dates should be included. The default value is false. (optional)
     * @param  bool $show_thread_messages Whether thread messages should be included in the response (optional)
     * @param  bool $unreads Whether the number of unread messages should be included. The default value is false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsHistoryAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $sort = null, $count = null, $offset = null, $latest = null, $oldest = null, $inclusive = null, $show_thread_messages = null, $unreads = null, string $contentType = self::contentTypes['getApiV1ChannelsHistory'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsFiles200Response';
        $request = $this->getApiV1ChannelsHistoryRequest($x_auth_token, $x_user_id, $room_id, $room_name, $sort, $count, $offset, $latest, $oldest, $inclusive, $show_thread_messages, $unreads, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsHistory'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $latest The end of time range of messages to retrieve. The default value is the current date and time. (optional)
     * @param  string $oldest The start of the time range of messages to retrieve (optional)
     * @param  bool $inclusive Whether messages which land on the latest and oldest dates should be included. The default value is false. (optional)
     * @param  bool $show_thread_messages Whether thread messages should be included in the response (optional)
     * @param  bool $unreads Whether the number of unread messages should be included. The default value is false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApiV1ChannelsHistoryRequest($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $sort = null, $count = null, $offset = null, $latest = null, $oldest = null, $inclusive = null, $show_thread_messages = null, $unreads = null, string $contentType = self::contentTypes['getApiV1ChannelsHistory'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsHistory'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsHistory'
            );
        }












        $resourcePath = '/api/v1/channels.history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_id,
            'roomId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_name,
            'roomName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latest,
            'latest', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $oldest,
            'oldest', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $inclusive,
            'inclusive', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_thread_messages,
            'showThreadMessages', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unreads,
            'unreads', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsInfo
     *
     * Get Channel Information
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsInfo'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response
     */
    public function getApiV1ChannelsInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, string $contentType = self::contentTypes['getApiV1ChannelsInfo'][0])
    {
        list($response) = $this->getApiV1ChannelsInfoWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name, $contentType);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsInfoWithHttpInfo
     *
     * Get Channel Information
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsInfo'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsInfoWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, string $contentType = self::contentTypes['getApiV1ChannelsInfo'][0])
    {
        $request = $this->getApiV1ChannelsInfoRequest($x_auth_token, $x_user_id, $room_id, $room_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsInfoAsync
     *
     * Get Channel Information
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsInfoAsync($x_auth_token, $x_user_id, $room_id = null, $room_name = null, string $contentType = self::contentTypes['getApiV1ChannelsInfo'][0])
    {
        return $this->getApiV1ChannelsInfoAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsInfoAsyncWithHttpInfo
     *
     * Get Channel Information
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsInfoAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, string $contentType = self::contentTypes['getApiV1ChannelsInfo'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response';
        $request = $this->getApiV1ChannelsInfoRequest($x_auth_token, $x_user_id, $room_id, $room_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsInfo'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApiV1ChannelsInfoRequest($x_auth_token, $x_user_id, $room_id = null, $room_name = null, string $contentType = self::contentTypes['getApiV1ChannelsInfo'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsInfo'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsInfo'
            );
        }




        $resourcePath = '/api/v1/channels.info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_id,
            'roomId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_name,
            'roomName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsList
     *
     * Get Channel List
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsList'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\GetApiV1ChannelsList200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function getApiV1ChannelsList($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null, string $contentType = self::contentTypes['getApiV1ChannelsList'][0])
    {
        list($response) = $this->getApiV1ChannelsListWithHttpInfo($x_auth_token, $x_user_id, $offset, $count, $sort, $query, $fields, $contentType);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsListWithHttpInfo
     *
     * Get Channel List
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsList'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\GetApiV1ChannelsList200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsListWithHttpInfo($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null, string $contentType = self::contentTypes['getApiV1ChannelsList'][0])
    {
        $request = $this->getApiV1ChannelsListRequest($x_auth_token, $x_user_id, $offset, $count, $sort, $query, $fields, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsList200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsList200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\GetApiV1ChannelsList200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsList200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\GetApiV1ChannelsList200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsListAsync
     *
     * Get Channel List
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsListAsync($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null, string $contentType = self::contentTypes['getApiV1ChannelsList'][0])
    {
        return $this->getApiV1ChannelsListAsyncWithHttpInfo($x_auth_token, $x_user_id, $offset, $count, $sort, $query, $fields, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsListAsyncWithHttpInfo
     *
     * Get Channel List
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsListAsyncWithHttpInfo($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null, string $contentType = self::contentTypes['getApiV1ChannelsList'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsList200Response';
        $request = $this->getApiV1ChannelsListRequest($x_auth_token, $x_user_id, $offset, $count, $sort, $query, $fields, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsList'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApiV1ChannelsListRequest($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null, string $contentType = self::contentTypes['getApiV1ChannelsList'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsList'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsList'
            );
        }







        $resourcePath = '/api/v1/channels.list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsListJoined
     *
     * Get List of Joined Channels
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsListJoined'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\GetApiV1ChannelsListJoined200Response
     */
    public function getApiV1ChannelsListJoined($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null, string $contentType = self::contentTypes['getApiV1ChannelsListJoined'][0])
    {
        list($response) = $this->getApiV1ChannelsListJoinedWithHttpInfo($x_auth_token, $x_user_id, $offset, $count, $sort, $query, $fields, $contentType);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsListJoinedWithHttpInfo
     *
     * Get List of Joined Channels
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsListJoined'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\GetApiV1ChannelsListJoined200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsListJoinedWithHttpInfo($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null, string $contentType = self::contentTypes['getApiV1ChannelsListJoined'][0])
    {
        $request = $this->getApiV1ChannelsListJoinedRequest($x_auth_token, $x_user_id, $offset, $count, $sort, $query, $fields, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsListJoined200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsListJoined200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\GetApiV1ChannelsListJoined200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsListJoined200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\GetApiV1ChannelsListJoined200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsListJoinedAsync
     *
     * Get List of Joined Channels
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsListJoined'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsListJoinedAsync($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null, string $contentType = self::contentTypes['getApiV1ChannelsListJoined'][0])
    {
        return $this->getApiV1ChannelsListJoinedAsyncWithHttpInfo($x_auth_token, $x_user_id, $offset, $count, $sort, $query, $fields, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsListJoinedAsyncWithHttpInfo
     *
     * Get List of Joined Channels
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsListJoined'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsListJoinedAsyncWithHttpInfo($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null, string $contentType = self::contentTypes['getApiV1ChannelsListJoined'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsListJoined200Response';
        $request = $this->getApiV1ChannelsListJoinedRequest($x_auth_token, $x_user_id, $offset, $count, $sort, $query, $fields, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsListJoined'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: fields&#x3D;{ \&quot;username\&quot;: 1 } (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsListJoined'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApiV1ChannelsListJoinedRequest($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null, string $contentType = self::contentTypes['getApiV1ChannelsListJoined'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsListJoined'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsListJoined'
            );
        }







        $resourcePath = '/api/v1/channels.list.joined';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsMembers
     *
     * Get Members of a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string[] $status The user&#39;s status (search filter). (optional)
     * @param  string $filter Extra search filters to be applied to the fields defined in the &#x60;Accounts_SearchFields&#x60;setting. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsMembers'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\GetApiV1ChannelsMembers200Response
     */
    public function getApiV1ChannelsMembers($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $status = null, $filter = null, $sort = null, $count = null, $offset = null, string $contentType = self::contentTypes['getApiV1ChannelsMembers'][0])
    {
        list($response) = $this->getApiV1ChannelsMembersWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name, $status, $filter, $sort, $count, $offset, $contentType);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsMembersWithHttpInfo
     *
     * Get Members of a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string[] $status The user&#39;s status (search filter). (optional)
     * @param  string $filter Extra search filters to be applied to the fields defined in the &#x60;Accounts_SearchFields&#x60;setting. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsMembers'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\GetApiV1ChannelsMembers200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsMembersWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $status = null, $filter = null, $sort = null, $count = null, $offset = null, string $contentType = self::contentTypes['getApiV1ChannelsMembers'][0])
    {
        $request = $this->getApiV1ChannelsMembersRequest($x_auth_token, $x_user_id, $room_id, $room_name, $status, $filter, $sort, $count, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsMembers200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsMembers200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\GetApiV1ChannelsMembers200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsMembers200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\GetApiV1ChannelsMembers200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsMembersAsync
     *
     * Get Members of a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string[] $status The user&#39;s status (search filter). (optional)
     * @param  string $filter Extra search filters to be applied to the fields defined in the &#x60;Accounts_SearchFields&#x60;setting. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsMembersAsync($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $status = null, $filter = null, $sort = null, $count = null, $offset = null, string $contentType = self::contentTypes['getApiV1ChannelsMembers'][0])
    {
        return $this->getApiV1ChannelsMembersAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name, $status, $filter, $sort, $count, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsMembersAsyncWithHttpInfo
     *
     * Get Members of a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string[] $status The user&#39;s status (search filter). (optional)
     * @param  string $filter Extra search filters to be applied to the fields defined in the &#x60;Accounts_SearchFields&#x60;setting. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsMembersAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $status = null, $filter = null, $sort = null, $count = null, $offset = null, string $contentType = self::contentTypes['getApiV1ChannelsMembers'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsMembers200Response';
        $request = $this->getApiV1ChannelsMembersRequest($x_auth_token, $x_user_id, $room_id, $room_name, $status, $filter, $sort, $count, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsMembers'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string[] $status The user&#39;s status (search filter). (optional)
     * @param  string $filter Extra search filters to be applied to the fields defined in the &#x60;Accounts_SearchFields&#x60;setting. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApiV1ChannelsMembersRequest($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $status = null, $filter = null, $sort = null, $count = null, $offset = null, string $contentType = self::contentTypes['getApiV1ChannelsMembers'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsMembers'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsMembers'
            );
        }









        $resourcePath = '/api/v1/channels.members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_id,
            'roomId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_name,
            'roomName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter,
            'filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsMessages
     *
     * Get Channel Messages
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsMessages'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\GetApiV1ChannelsMessages200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function getApiV1ChannelsMessages($x_auth_token, $x_user_id, $room_id, $count = null, $sort = null, $query = null, $offset = null, string $contentType = self::contentTypes['getApiV1ChannelsMessages'][0])
    {
        list($response) = $this->getApiV1ChannelsMessagesWithHttpInfo($x_auth_token, $x_user_id, $room_id, $count, $sort, $query, $offset, $contentType);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsMessagesWithHttpInfo
     *
     * Get Channel Messages
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsMessages'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\GetApiV1ChannelsMessages200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsMessagesWithHttpInfo($x_auth_token, $x_user_id, $room_id, $count = null, $sort = null, $query = null, $offset = null, string $contentType = self::contentTypes['getApiV1ChannelsMessages'][0])
    {
        $request = $this->getApiV1ChannelsMessagesRequest($x_auth_token, $x_user_id, $room_id, $count, $sort, $query, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsMessages200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsMessages200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\GetApiV1ChannelsMessages200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsMessages200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\GetApiV1ChannelsMessages200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsMessagesAsync
     *
     * Get Channel Messages
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsMessagesAsync($x_auth_token, $x_user_id, $room_id, $count = null, $sort = null, $query = null, $offset = null, string $contentType = self::contentTypes['getApiV1ChannelsMessages'][0])
    {
        return $this->getApiV1ChannelsMessagesAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $count, $sort, $query, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsMessagesAsyncWithHttpInfo
     *
     * Get Channel Messages
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsMessagesAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $count = null, $sort = null, $query = null, $offset = null, string $contentType = self::contentTypes['getApiV1ChannelsMessages'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsMessages200Response';
        $request = $this->getApiV1ChannelsMessagesRequest($x_auth_token, $x_user_id, $room_id, $count, $sort, $query, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsMessages'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  mixed $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } } (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApiV1ChannelsMessagesRequest($x_auth_token, $x_user_id, $room_id, $count = null, $sort = null, $query = null, $offset = null, string $contentType = self::contentTypes['getApiV1ChannelsMessages'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsMessages'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsMessages'
            );
        }

        // verify the required parameter 'room_id' is set
        if ($room_id === null || (is_array($room_id) && count($room_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $room_id when calling getApiV1ChannelsMessages'
            );
        }






        $resourcePath = '/api/v1/channels.messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_id,
            'roomId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsModerators
     *
     * Get Channel Moderators
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsModerators'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\GetApiV1ChannelsModerators200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function getApiV1ChannelsModerators($x_auth_token, $x_user_id, $room_id = null, $room_name = null, string $contentType = self::contentTypes['getApiV1ChannelsModerators'][0])
    {
        list($response) = $this->getApiV1ChannelsModeratorsWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name, $contentType);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsModeratorsWithHttpInfo
     *
     * Get Channel Moderators
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsModerators'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\GetApiV1ChannelsModerators200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsModeratorsWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, string $contentType = self::contentTypes['getApiV1ChannelsModerators'][0])
    {
        $request = $this->getApiV1ChannelsModeratorsRequest($x_auth_token, $x_user_id, $room_id, $room_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsModerators200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsModerators200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\GetApiV1ChannelsModerators200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsModerators200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\GetApiV1ChannelsModerators200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsModeratorsAsync
     *
     * Get Channel Moderators
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsModerators'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsModeratorsAsync($x_auth_token, $x_user_id, $room_id = null, $room_name = null, string $contentType = self::contentTypes['getApiV1ChannelsModerators'][0])
    {
        return $this->getApiV1ChannelsModeratorsAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsModeratorsAsyncWithHttpInfo
     *
     * Get Channel Moderators
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsModerators'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsModeratorsAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, string $contentType = self::contentTypes['getApiV1ChannelsModerators'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsModerators200Response';
        $request = $this->getApiV1ChannelsModeratorsRequest($x_auth_token, $x_user_id, $room_id, $room_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsModerators'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsModerators'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApiV1ChannelsModeratorsRequest($x_auth_token, $x_user_id, $room_id = null, $room_name = null, string $contentType = self::contentTypes['getApiV1ChannelsModerators'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsModerators'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsModerators'
            );
        }




        $resourcePath = '/api/v1/channels.moderators';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_id,
            'roomId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_name,
            'roomName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsOnline
     *
     * List Online Users in a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  GetApiV1ChannelsOnlineQueryParameter $query An object of the channel&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsOnline'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\GetApiV1ChannelsOnline200Response
     */
    public function getApiV1ChannelsOnline($x_auth_token, $x_user_id, $query, string $contentType = self::contentTypes['getApiV1ChannelsOnline'][0])
    {
        list($response) = $this->getApiV1ChannelsOnlineWithHttpInfo($x_auth_token, $x_user_id, $query, $contentType);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsOnlineWithHttpInfo
     *
     * List Online Users in a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  GetApiV1ChannelsOnlineQueryParameter $query An object of the channel&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsOnline'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\GetApiV1ChannelsOnline200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsOnlineWithHttpInfo($x_auth_token, $x_user_id, $query, string $contentType = self::contentTypes['getApiV1ChannelsOnline'][0])
    {
        $request = $this->getApiV1ChannelsOnlineRequest($x_auth_token, $x_user_id, $query, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsOnline200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsOnline200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\GetApiV1ChannelsOnline200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsOnline200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\GetApiV1ChannelsOnline200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsOnlineAsync
     *
     * List Online Users in a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  GetApiV1ChannelsOnlineQueryParameter $query An object of the channel&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsOnline'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsOnlineAsync($x_auth_token, $x_user_id, $query, string $contentType = self::contentTypes['getApiV1ChannelsOnline'][0])
    {
        return $this->getApiV1ChannelsOnlineAsyncWithHttpInfo($x_auth_token, $x_user_id, $query, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsOnlineAsyncWithHttpInfo
     *
     * List Online Users in a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  GetApiV1ChannelsOnlineQueryParameter $query An object of the channel&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsOnline'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsOnlineAsyncWithHttpInfo($x_auth_token, $x_user_id, $query, string $contentType = self::contentTypes['getApiV1ChannelsOnline'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsOnline200Response';
        $request = $this->getApiV1ChannelsOnlineRequest($x_auth_token, $x_user_id, $query, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsOnline'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  GetApiV1ChannelsOnlineQueryParameter $query An object of the channel&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsOnline'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApiV1ChannelsOnlineRequest($x_auth_token, $x_user_id, $query, string $contentType = self::contentTypes['getApiV1ChannelsOnline'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsOnline'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsOnline'
            );
        }

        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling getApiV1ChannelsOnline'
            );
        }


        $resourcePath = '/api/v1/channels.online';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsRoles
     *
     * Get Channel Roles
     *
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsRoles'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\GetApiV1ChannelsRoles200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function getApiV1ChannelsRoles($room_id = null, $room_name = null, string $contentType = self::contentTypes['getApiV1ChannelsRoles'][0])
    {
        list($response) = $this->getApiV1ChannelsRolesWithHttpInfo($room_id, $room_name, $contentType);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsRolesWithHttpInfo
     *
     * Get Channel Roles
     *
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsRoles'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\GetApiV1ChannelsRoles200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsRolesWithHttpInfo($room_id = null, $room_name = null, string $contentType = self::contentTypes['getApiV1ChannelsRoles'][0])
    {
        $request = $this->getApiV1ChannelsRolesRequest($room_id, $room_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsRoles200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\GetApiV1ChannelsRoles200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\GetApiV1ChannelsRoles200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsRoles200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\GetApiV1ChannelsRoles200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsRolesAsync
     *
     * Get Channel Roles
     *
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsRoles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsRolesAsync($room_id = null, $room_name = null, string $contentType = self::contentTypes['getApiV1ChannelsRoles'][0])
    {
        return $this->getApiV1ChannelsRolesAsyncWithHttpInfo($room_id, $room_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsRolesAsyncWithHttpInfo
     *
     * Get Channel Roles
     *
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsRoles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsRolesAsyncWithHttpInfo($room_id = null, $room_name = null, string $contentType = self::contentTypes['getApiV1ChannelsRoles'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\GetApiV1ChannelsRoles200Response';
        $request = $this->getApiV1ChannelsRolesRequest($room_id, $room_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsRoles'
     *
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApiV1ChannelsRoles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApiV1ChannelsRolesRequest($room_id = null, $room_name = null, string $contentType = self::contentTypes['getApiV1ChannelsRoles'][0])
    {




        $resourcePath = '/api/v1/channels.roles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_id,
            'roomId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_name,
            'roomName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChannelsMembersByHighestRole
     *
     * List Channel Members By Highest Role
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string[] $status The user&#39;s status (search filter). (optional)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $filter Extra search filters to be applied to the fields defined in the &#x60;Accounts_SearchFields&#x60; setting. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannelsMembersByHighestRole'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\GetChannelsMembersByHighestRole200Response
     */
    public function getChannelsMembersByHighestRole($x_auth_token, $x_user_id, $status = null, $room_id = null, $room_name = null, $filter = null, $count = null, $sort = null, $offset = null, string $contentType = self::contentTypes['getChannelsMembersByHighestRole'][0])
    {
        list($response) = $this->getChannelsMembersByHighestRoleWithHttpInfo($x_auth_token, $x_user_id, $status, $room_id, $room_name, $filter, $count, $sort, $offset, $contentType);
        return $response;
    }

    /**
     * Operation getChannelsMembersByHighestRoleWithHttpInfo
     *
     * List Channel Members By Highest Role
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string[] $status The user&#39;s status (search filter). (optional)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $filter Extra search filters to be applied to the fields defined in the &#x60;Accounts_SearchFields&#x60; setting. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannelsMembersByHighestRole'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\GetChannelsMembersByHighestRole200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChannelsMembersByHighestRoleWithHttpInfo($x_auth_token, $x_user_id, $status = null, $room_id = null, $room_name = null, $filter = null, $count = null, $sort = null, $offset = null, string $contentType = self::contentTypes['getChannelsMembersByHighestRole'][0])
    {
        $request = $this->getChannelsMembersByHighestRoleRequest($x_auth_token, $x_user_id, $status, $room_id, $room_name, $filter, $count, $sort, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\GetChannelsMembersByHighestRole200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\GetChannelsMembersByHighestRole200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\GetChannelsMembersByHighestRole200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\GetChannelsMembersByHighestRole200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\GetChannelsMembersByHighestRole200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getChannelsMembersByHighestRoleAsync
     *
     * List Channel Members By Highest Role
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string[] $status The user&#39;s status (search filter). (optional)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $filter Extra search filters to be applied to the fields defined in the &#x60;Accounts_SearchFields&#x60; setting. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannelsMembersByHighestRole'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChannelsMembersByHighestRoleAsync($x_auth_token, $x_user_id, $status = null, $room_id = null, $room_name = null, $filter = null, $count = null, $sort = null, $offset = null, string $contentType = self::contentTypes['getChannelsMembersByHighestRole'][0])
    {
        return $this->getChannelsMembersByHighestRoleAsyncWithHttpInfo($x_auth_token, $x_user_id, $status, $room_id, $room_name, $filter, $count, $sort, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChannelsMembersByHighestRoleAsyncWithHttpInfo
     *
     * List Channel Members By Highest Role
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string[] $status The user&#39;s status (search filter). (optional)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $filter Extra search filters to be applied to the fields defined in the &#x60;Accounts_SearchFields&#x60; setting. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannelsMembersByHighestRole'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChannelsMembersByHighestRoleAsyncWithHttpInfo($x_auth_token, $x_user_id, $status = null, $room_id = null, $room_name = null, $filter = null, $count = null, $sort = null, $offset = null, string $contentType = self::contentTypes['getChannelsMembersByHighestRole'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\GetChannelsMembersByHighestRole200Response';
        $request = $this->getChannelsMembersByHighestRoleRequest($x_auth_token, $x_user_id, $status, $room_id, $room_name, $filter, $count, $sort, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChannelsMembersByHighestRole'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string[] $status The user&#39;s status (search filter). (optional)
     * @param  string $room_id The room id. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $filter Extra search filters to be applied to the fields defined in the &#x60;Accounts_SearchFields&#x60; setting. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  mixed $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannelsMembersByHighestRole'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getChannelsMembersByHighestRoleRequest($x_auth_token, $x_user_id, $status = null, $room_id = null, $room_name = null, $filter = null, $count = null, $sort = null, $offset = null, string $contentType = self::contentTypes['getChannelsMembersByHighestRole'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getChannelsMembersByHighestRole'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getChannelsMembersByHighestRole'
            );
        }









        $resourcePath = '/api/v1/channels.membersByHighestRole';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_id,
            'roomId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_name,
            'roomName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter,
            'filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation posApiV1ChannelsRename
     *
     * Rename a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PosApiV1ChannelsRenameRequest $pos_api_v1_channels_rename_request pos_api_v1_channels_rename_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['posApiV1ChannelsRename'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsLeave200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function posApiV1ChannelsRename($x_auth_token, $x_user_id, $pos_api_v1_channels_rename_request = null, string $contentType = self::contentTypes['posApiV1ChannelsRename'][0])
    {
        list($response) = $this->posApiV1ChannelsRenameWithHttpInfo($x_auth_token, $x_user_id, $pos_api_v1_channels_rename_request, $contentType);
        return $response;
    }

    /**
     * Operation posApiV1ChannelsRenameWithHttpInfo
     *
     * Rename a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PosApiV1ChannelsRenameRequest $pos_api_v1_channels_rename_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['posApiV1ChannelsRename'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsLeave200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function posApiV1ChannelsRenameWithHttpInfo($x_auth_token, $x_user_id, $pos_api_v1_channels_rename_request = null, string $contentType = self::contentTypes['posApiV1ChannelsRename'][0])
    {
        $request = $this->posApiV1ChannelsRenameRequest($x_auth_token, $x_user_id, $pos_api_v1_channels_rename_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsLeave200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsLeave200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsLeave200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsLeave200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsLeave200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation posApiV1ChannelsRenameAsync
     *
     * Rename a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PosApiV1ChannelsRenameRequest $pos_api_v1_channels_rename_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['posApiV1ChannelsRename'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function posApiV1ChannelsRenameAsync($x_auth_token, $x_user_id, $pos_api_v1_channels_rename_request = null, string $contentType = self::contentTypes['posApiV1ChannelsRename'][0])
    {
        return $this->posApiV1ChannelsRenameAsyncWithHttpInfo($x_auth_token, $x_user_id, $pos_api_v1_channels_rename_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation posApiV1ChannelsRenameAsyncWithHttpInfo
     *
     * Rename a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PosApiV1ChannelsRenameRequest $pos_api_v1_channels_rename_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['posApiV1ChannelsRename'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function posApiV1ChannelsRenameAsyncWithHttpInfo($x_auth_token, $x_user_id, $pos_api_v1_channels_rename_request = null, string $contentType = self::contentTypes['posApiV1ChannelsRename'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsLeave200Response';
        $request = $this->posApiV1ChannelsRenameRequest($x_auth_token, $x_user_id, $pos_api_v1_channels_rename_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'posApiV1ChannelsRename'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PosApiV1ChannelsRenameRequest $pos_api_v1_channels_rename_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['posApiV1ChannelsRename'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function posApiV1ChannelsRenameRequest($x_auth_token, $x_user_id, $pos_api_v1_channels_rename_request = null, string $contentType = self::contentTypes['posApiV1ChannelsRename'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling posApiV1ChannelsRename'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling posApiV1ChannelsRename'
            );
        }



        $resourcePath = '/api/v1/channels.rename';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($pos_api_v1_channels_rename_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($pos_api_v1_channels_rename_request));
            } else {
                $httpBody = $pos_api_v1_channels_rename_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsAddAll
     *
     * Add all Users to a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddAllRequest $post_api_v1_channels_add_all_request post_api_v1_channels_add_all_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddAll'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsAddAll($x_auth_token, $x_user_id, $post_api_v1_channels_add_all_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddAll'][0])
    {
        list($response) = $this->postApiV1ChannelsAddAllWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_add_all_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsAddAllWithHttpInfo
     *
     * Add all Users to a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddAllRequest $post_api_v1_channels_add_all_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddAll'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsAddAllWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_add_all_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddAll'][0])
    {
        $request = $this->postApiV1ChannelsAddAllRequest($x_auth_token, $x_user_id, $post_api_v1_channels_add_all_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsAddAllAsync
     *
     * Add all Users to a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddAllRequest $post_api_v1_channels_add_all_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsAddAllAsync($x_auth_token, $x_user_id, $post_api_v1_channels_add_all_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddAll'][0])
    {
        return $this->postApiV1ChannelsAddAllAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_add_all_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsAddAllAsyncWithHttpInfo
     *
     * Add all Users to a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddAllRequest $post_api_v1_channels_add_all_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsAddAllAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_add_all_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddAll'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response';
        $request = $this->postApiV1ChannelsAddAllRequest($x_auth_token, $x_user_id, $post_api_v1_channels_add_all_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsAddAll'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddAllRequest $post_api_v1_channels_add_all_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsAddAllRequest($x_auth_token, $x_user_id, $post_api_v1_channels_add_all_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddAll'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsAddAll'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsAddAll'
            );
        }



        $resourcePath = '/api/v1/channels.addAll';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_add_all_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_add_all_request));
            } else {
                $httpBody = $post_api_v1_channels_add_all_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsAddLeader
     *
     * Add Channel Leader
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeaderRequest $post_api_v1_channels_add_leader_request post_api_v1_channels_add_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddLeader'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsAddLeader($x_auth_token, $x_user_id, $post_api_v1_channels_add_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddLeader'][0])
    {
        list($response) = $this->postApiV1ChannelsAddLeaderWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_add_leader_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsAddLeaderWithHttpInfo
     *
     * Add Channel Leader
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeaderRequest $post_api_v1_channels_add_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddLeader'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsAddLeaderWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_add_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddLeader'][0])
    {
        $request = $this->postApiV1ChannelsAddLeaderRequest($x_auth_token, $x_user_id, $post_api_v1_channels_add_leader_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsAddLeaderAsync
     *
     * Add Channel Leader
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeaderRequest $post_api_v1_channels_add_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddLeader'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsAddLeaderAsync($x_auth_token, $x_user_id, $post_api_v1_channels_add_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddLeader'][0])
    {
        return $this->postApiV1ChannelsAddLeaderAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_add_leader_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsAddLeaderAsyncWithHttpInfo
     *
     * Add Channel Leader
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeaderRequest $post_api_v1_channels_add_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddLeader'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsAddLeaderAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_add_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddLeader'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
        $request = $this->postApiV1ChannelsAddLeaderRequest($x_auth_token, $x_user_id, $post_api_v1_channels_add_leader_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsAddLeader'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeaderRequest $post_api_v1_channels_add_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddLeader'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsAddLeaderRequest($x_auth_token, $x_user_id, $post_api_v1_channels_add_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddLeader'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsAddLeader'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsAddLeader'
            );
        }



        $resourcePath = '/api/v1/channels.addLeader';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_add_leader_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_add_leader_request));
            } else {
                $httpBody = $post_api_v1_channels_add_leader_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsAddModerator
     *
     * Add Channel Moderator
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddModeratorRequest $post_api_v1_channels_add_moderator_request post_api_v1_channels_add_moderator_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddModerator'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsAddModerator($x_auth_token, $x_user_id, $post_api_v1_channels_add_moderator_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddModerator'][0])
    {
        list($response) = $this->postApiV1ChannelsAddModeratorWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_add_moderator_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsAddModeratorWithHttpInfo
     *
     * Add Channel Moderator
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddModeratorRequest $post_api_v1_channels_add_moderator_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddModerator'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsAddModeratorWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_add_moderator_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddModerator'][0])
    {
        $request = $this->postApiV1ChannelsAddModeratorRequest($x_auth_token, $x_user_id, $post_api_v1_channels_add_moderator_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsAddModeratorAsync
     *
     * Add Channel Moderator
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddModeratorRequest $post_api_v1_channels_add_moderator_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddModerator'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsAddModeratorAsync($x_auth_token, $x_user_id, $post_api_v1_channels_add_moderator_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddModerator'][0])
    {
        return $this->postApiV1ChannelsAddModeratorAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_add_moderator_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsAddModeratorAsyncWithHttpInfo
     *
     * Add Channel Moderator
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddModeratorRequest $post_api_v1_channels_add_moderator_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddModerator'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsAddModeratorAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_add_moderator_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddModerator'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
        $request = $this->postApiV1ChannelsAddModeratorRequest($x_auth_token, $x_user_id, $post_api_v1_channels_add_moderator_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsAddModerator'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddModeratorRequest $post_api_v1_channels_add_moderator_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddModerator'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsAddModeratorRequest($x_auth_token, $x_user_id, $post_api_v1_channels_add_moderator_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddModerator'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsAddModerator'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsAddModerator'
            );
        }



        $resourcePath = '/api/v1/channels.addModerator';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_add_moderator_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_add_moderator_request));
            } else {
                $httpBody = $post_api_v1_channels_add_moderator_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsAddOwner
     *
     * Add Channel Owner
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwnerRequest $post_api_v1_channels_add_owner_request post_api_v1_channels_add_owner_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddOwner'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwner400Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsAddOwner($x_auth_token, $x_user_id, $post_api_v1_channels_add_owner_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddOwner'][0])
    {
        list($response) = $this->postApiV1ChannelsAddOwnerWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_add_owner_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsAddOwnerWithHttpInfo
     *
     * Add Channel Owner
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwnerRequest $post_api_v1_channels_add_owner_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddOwner'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwner400Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsAddOwnerWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_add_owner_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddOwner'][0])
    {
        $request = $this->postApiV1ChannelsAddOwnerRequest($x_auth_token, $x_user_id, $post_api_v1_channels_add_owner_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwner400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwner400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwner400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwner400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsAddOwnerAsync
     *
     * Add Channel Owner
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwnerRequest $post_api_v1_channels_add_owner_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddOwner'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsAddOwnerAsync($x_auth_token, $x_user_id, $post_api_v1_channels_add_owner_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddOwner'][0])
    {
        return $this->postApiV1ChannelsAddOwnerAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_add_owner_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsAddOwnerAsyncWithHttpInfo
     *
     * Add Channel Owner
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwnerRequest $post_api_v1_channels_add_owner_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddOwner'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsAddOwnerAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_add_owner_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddOwner'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
        $request = $this->postApiV1ChannelsAddOwnerRequest($x_auth_token, $x_user_id, $post_api_v1_channels_add_owner_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsAddOwner'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwnerRequest $post_api_v1_channels_add_owner_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsAddOwner'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsAddOwnerRequest($x_auth_token, $x_user_id, $post_api_v1_channels_add_owner_request = null, string $contentType = self::contentTypes['postApiV1ChannelsAddOwner'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsAddOwner'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsAddOwner'
            );
        }



        $resourcePath = '/api/v1/channels.addOwner';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_add_owner_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_add_owner_request));
            } else {
                $httpBody = $post_api_v1_channels_add_owner_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsArchive
     *
     * Archive Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsArchiveRequest $post_api_v1_channels_archive_request post_api_v1_channels_archive_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsArchive'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsArchive($x_auth_token, $x_user_id, $post_api_v1_channels_archive_request = null, string $contentType = self::contentTypes['postApiV1ChannelsArchive'][0])
    {
        list($response) = $this->postApiV1ChannelsArchiveWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_archive_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsArchiveWithHttpInfo
     *
     * Archive Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsArchiveRequest $post_api_v1_channels_archive_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsArchive'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsArchiveWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_archive_request = null, string $contentType = self::contentTypes['postApiV1ChannelsArchive'][0])
    {
        $request = $this->postApiV1ChannelsArchiveRequest($x_auth_token, $x_user_id, $post_api_v1_channels_archive_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsArchiveAsync
     *
     * Archive Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsArchiveRequest $post_api_v1_channels_archive_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsArchive'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsArchiveAsync($x_auth_token, $x_user_id, $post_api_v1_channels_archive_request = null, string $contentType = self::contentTypes['postApiV1ChannelsArchive'][0])
    {
        return $this->postApiV1ChannelsArchiveAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_archive_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsArchiveAsyncWithHttpInfo
     *
     * Archive Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsArchiveRequest $post_api_v1_channels_archive_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsArchive'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsArchiveAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_archive_request = null, string $contentType = self::contentTypes['postApiV1ChannelsArchive'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
        $request = $this->postApiV1ChannelsArchiveRequest($x_auth_token, $x_user_id, $post_api_v1_channels_archive_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsArchive'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsArchiveRequest $post_api_v1_channels_archive_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsArchive'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsArchiveRequest($x_auth_token, $x_user_id, $post_api_v1_channels_archive_request = null, string $contentType = self::contentTypes['postApiV1ChannelsArchive'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsArchive'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsArchive'
            );
        }



        $resourcePath = '/api/v1/channels.archive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_archive_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_archive_request));
            } else {
                $httpBody = $post_api_v1_channels_archive_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsClose
     *
     * Close Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsCloseRequest $post_api_v1_channels_close_request post_api_v1_channels_close_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsClose'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsClose400Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsClose($x_auth_token, $x_user_id, $post_api_v1_channels_close_request = null, string $contentType = self::contentTypes['postApiV1ChannelsClose'][0])
    {
        list($response) = $this->postApiV1ChannelsCloseWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_close_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsCloseWithHttpInfo
     *
     * Close Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsCloseRequest $post_api_v1_channels_close_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsClose'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsClose400Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsCloseWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_close_request = null, string $contentType = self::contentTypes['postApiV1ChannelsClose'][0])
    {
        $request = $this->postApiV1ChannelsCloseRequest($x_auth_token, $x_user_id, $post_api_v1_channels_close_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsClose400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsClose400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsClose400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsClose400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsCloseAsync
     *
     * Close Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsCloseRequest $post_api_v1_channels_close_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsClose'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsCloseAsync($x_auth_token, $x_user_id, $post_api_v1_channels_close_request = null, string $contentType = self::contentTypes['postApiV1ChannelsClose'][0])
    {
        return $this->postApiV1ChannelsCloseAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_close_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsCloseAsyncWithHttpInfo
     *
     * Close Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsCloseRequest $post_api_v1_channels_close_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsClose'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsCloseAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_close_request = null, string $contentType = self::contentTypes['postApiV1ChannelsClose'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
        $request = $this->postApiV1ChannelsCloseRequest($x_auth_token, $x_user_id, $post_api_v1_channels_close_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsClose'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsCloseRequest $post_api_v1_channels_close_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsClose'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsCloseRequest($x_auth_token, $x_user_id, $post_api_v1_channels_close_request = null, string $contentType = self::contentTypes['postApiV1ChannelsClose'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsClose'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsClose'
            );
        }



        $resourcePath = '/api/v1/channels.close';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_close_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_close_request));
            } else {
                $httpBody = $post_api_v1_channels_close_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsConvertToTeam
     *
     * Convert channel to team
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsConvertToTeamRequest $post_api_v1_channels_convert_to_team_request post_api_v1_channels_convert_to_team_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsConvertToTeam'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsConvertToTeam200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsConvertToTeam($x_auth_token, $x_user_id, $post_api_v1_channels_convert_to_team_request = null, string $contentType = self::contentTypes['postApiV1ChannelsConvertToTeam'][0])
    {
        list($response) = $this->postApiV1ChannelsConvertToTeamWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_convert_to_team_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsConvertToTeamWithHttpInfo
     *
     * Convert channel to team
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsConvertToTeamRequest $post_api_v1_channels_convert_to_team_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsConvertToTeam'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsConvertToTeam200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsConvertToTeamWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_convert_to_team_request = null, string $contentType = self::contentTypes['postApiV1ChannelsConvertToTeam'][0])
    {
        $request = $this->postApiV1ChannelsConvertToTeamRequest($x_auth_token, $x_user_id, $post_api_v1_channels_convert_to_team_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsConvertToTeam200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsConvertToTeam200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsConvertToTeam200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsConvertToTeam200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsConvertToTeam200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsConvertToTeamAsync
     *
     * Convert channel to team
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsConvertToTeamRequest $post_api_v1_channels_convert_to_team_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsConvertToTeam'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsConvertToTeamAsync($x_auth_token, $x_user_id, $post_api_v1_channels_convert_to_team_request = null, string $contentType = self::contentTypes['postApiV1ChannelsConvertToTeam'][0])
    {
        return $this->postApiV1ChannelsConvertToTeamAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_convert_to_team_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsConvertToTeamAsyncWithHttpInfo
     *
     * Convert channel to team
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsConvertToTeamRequest $post_api_v1_channels_convert_to_team_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsConvertToTeam'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsConvertToTeamAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_convert_to_team_request = null, string $contentType = self::contentTypes['postApiV1ChannelsConvertToTeam'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsConvertToTeam200Response';
        $request = $this->postApiV1ChannelsConvertToTeamRequest($x_auth_token, $x_user_id, $post_api_v1_channels_convert_to_team_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsConvertToTeam'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsConvertToTeamRequest $post_api_v1_channels_convert_to_team_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsConvertToTeam'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsConvertToTeamRequest($x_auth_token, $x_user_id, $post_api_v1_channels_convert_to_team_request = null, string $contentType = self::contentTypes['postApiV1ChannelsConvertToTeam'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsConvertToTeam'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsConvertToTeam'
            );
        }



        $resourcePath = '/api/v1/channels.convertToTeam';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_convert_to_team_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_convert_to_team_request));
            } else {
                $httpBody = $post_api_v1_channels_convert_to_team_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsCreate
     *
     * Create Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsCreateRequest $post_api_v1_channels_create_request post_api_v1_channels_create_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsCreate'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsCreate200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsCreate($x_auth_token, $x_user_id, $post_api_v1_channels_create_request = null, string $contentType = self::contentTypes['postApiV1ChannelsCreate'][0])
    {
        list($response) = $this->postApiV1ChannelsCreateWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_create_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsCreateWithHttpInfo
     *
     * Create Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsCreateRequest $post_api_v1_channels_create_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsCreate'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsCreate200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsCreateWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_create_request = null, string $contentType = self::contentTypes['postApiV1ChannelsCreate'][0])
    {
        $request = $this->postApiV1ChannelsCreateRequest($x_auth_token, $x_user_id, $post_api_v1_channels_create_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsCreateAsync
     *
     * Create Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsCreateRequest $post_api_v1_channels_create_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsCreateAsync($x_auth_token, $x_user_id, $post_api_v1_channels_create_request = null, string $contentType = self::contentTypes['postApiV1ChannelsCreate'][0])
    {
        return $this->postApiV1ChannelsCreateAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_create_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsCreateAsyncWithHttpInfo
     *
     * Create Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsCreateRequest $post_api_v1_channels_create_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsCreateAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_create_request = null, string $contentType = self::contentTypes['postApiV1ChannelsCreate'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate200Response';
        $request = $this->postApiV1ChannelsCreateRequest($x_auth_token, $x_user_id, $post_api_v1_channels_create_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsCreate'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsCreateRequest $post_api_v1_channels_create_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsCreateRequest($x_auth_token, $x_user_id, $post_api_v1_channels_create_request = null, string $contentType = self::contentTypes['postApiV1ChannelsCreate'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsCreate'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsCreate'
            );
        }



        $resourcePath = '/api/v1/channels.create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_create_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_create_request));
            } else {
                $httpBody = $post_api_v1_channels_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsDelete
     *
     * Delete Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsDeleteRequest $post_api_v1_channels_delete_request post_api_v1_channels_delete_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsDelete'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response
     */
    public function postApiV1ChannelsDelete($x_auth_token, $x_user_id, $post_api_v1_channels_delete_request = null, string $contentType = self::contentTypes['postApiV1ChannelsDelete'][0])
    {
        list($response) = $this->postApiV1ChannelsDeleteWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_delete_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsDeleteWithHttpInfo
     *
     * Delete Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsDeleteRequest $post_api_v1_channels_delete_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsDelete'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsDeleteWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_delete_request = null, string $contentType = self::contentTypes['postApiV1ChannelsDelete'][0])
    {
        $request = $this->postApiV1ChannelsDeleteRequest($x_auth_token, $x_user_id, $post_api_v1_channels_delete_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsDeleteAsync
     *
     * Delete Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsDeleteRequest $post_api_v1_channels_delete_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsDeleteAsync($x_auth_token, $x_user_id, $post_api_v1_channels_delete_request = null, string $contentType = self::contentTypes['postApiV1ChannelsDelete'][0])
    {
        return $this->postApiV1ChannelsDeleteAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_delete_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsDeleteAsyncWithHttpInfo
     *
     * Delete Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsDeleteRequest $post_api_v1_channels_delete_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsDeleteAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_delete_request = null, string $contentType = self::contentTypes['postApiV1ChannelsDelete'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
        $request = $this->postApiV1ChannelsDeleteRequest($x_auth_token, $x_user_id, $post_api_v1_channels_delete_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsDelete'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsDeleteRequest $post_api_v1_channels_delete_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsDeleteRequest($x_auth_token, $x_user_id, $post_api_v1_channels_delete_request = null, string $contentType = self::contentTypes['postApiV1ChannelsDelete'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsDelete'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsDelete'
            );
        }



        $resourcePath = '/api/v1/channels.delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_delete_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_delete_request));
            } else {
                $httpBody = $post_api_v1_channels_delete_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsInvite
     *
     * Add Users to Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsInviteRequest $post_api_v1_channels_invite_request post_api_v1_channels_invite_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsInvite'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsInvite200Response
     */
    public function postApiV1ChannelsInvite($x_auth_token, $x_user_id, $post_api_v1_channels_invite_request = null, string $contentType = self::contentTypes['postApiV1ChannelsInvite'][0])
    {
        list($response) = $this->postApiV1ChannelsInviteWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_invite_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsInviteWithHttpInfo
     *
     * Add Users to Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsInviteRequest $post_api_v1_channels_invite_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsInvite'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsInvite200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsInviteWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_invite_request = null, string $contentType = self::contentTypes['postApiV1ChannelsInvite'][0])
    {
        $request = $this->postApiV1ChannelsInviteRequest($x_auth_token, $x_user_id, $post_api_v1_channels_invite_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsInvite200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsInvite200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsInvite200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsInvite200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsInvite200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsInviteAsync
     *
     * Add Users to Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsInviteRequest $post_api_v1_channels_invite_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsInvite'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsInviteAsync($x_auth_token, $x_user_id, $post_api_v1_channels_invite_request = null, string $contentType = self::contentTypes['postApiV1ChannelsInvite'][0])
    {
        return $this->postApiV1ChannelsInviteAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_invite_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsInviteAsyncWithHttpInfo
     *
     * Add Users to Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsInviteRequest $post_api_v1_channels_invite_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsInvite'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsInviteAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_invite_request = null, string $contentType = self::contentTypes['postApiV1ChannelsInvite'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsInvite200Response';
        $request = $this->postApiV1ChannelsInviteRequest($x_auth_token, $x_user_id, $post_api_v1_channels_invite_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsInvite'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsInviteRequest $post_api_v1_channels_invite_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsInvite'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsInviteRequest($x_auth_token, $x_user_id, $post_api_v1_channels_invite_request = null, string $contentType = self::contentTypes['postApiV1ChannelsInvite'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsInvite'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsInvite'
            );
        }



        $resourcePath = '/api/v1/channels.invite';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_invite_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_invite_request));
            } else {
                $httpBody = $post_api_v1_channels_invite_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsJoin
     *
     * Join a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsJoinRequest $post_api_v1_channels_join_request post_api_v1_channels_join_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsJoin'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response
     */
    public function postApiV1ChannelsJoin($x_auth_token, $x_user_id, $post_api_v1_channels_join_request = null, string $contentType = self::contentTypes['postApiV1ChannelsJoin'][0])
    {
        list($response) = $this->postApiV1ChannelsJoinWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_join_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsJoinWithHttpInfo
     *
     * Join a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsJoinRequest $post_api_v1_channels_join_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsJoin'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsJoinWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_join_request = null, string $contentType = self::contentTypes['postApiV1ChannelsJoin'][0])
    {
        $request = $this->postApiV1ChannelsJoinRequest($x_auth_token, $x_user_id, $post_api_v1_channels_join_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsJoinAsync
     *
     * Join a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsJoinRequest $post_api_v1_channels_join_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsJoin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsJoinAsync($x_auth_token, $x_user_id, $post_api_v1_channels_join_request = null, string $contentType = self::contentTypes['postApiV1ChannelsJoin'][0])
    {
        return $this->postApiV1ChannelsJoinAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_join_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsJoinAsyncWithHttpInfo
     *
     * Join a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsJoinRequest $post_api_v1_channels_join_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsJoin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsJoinAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_join_request = null, string $contentType = self::contentTypes['postApiV1ChannelsJoin'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response';
        $request = $this->postApiV1ChannelsJoinRequest($x_auth_token, $x_user_id, $post_api_v1_channels_join_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsJoin'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsJoinRequest $post_api_v1_channels_join_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsJoin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsJoinRequest($x_auth_token, $x_user_id, $post_api_v1_channels_join_request = null, string $contentType = self::contentTypes['postApiV1ChannelsJoin'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsJoin'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsJoin'
            );
        }



        $resourcePath = '/api/v1/channels.join';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_join_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_join_request));
            } else {
                $httpBody = $post_api_v1_channels_join_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsKick
     *
     * Remove User from Channel
     *
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsKickRequest $post_api_v1_channels_kick_request post_api_v1_channels_kick_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsKick'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response
     */
    public function postApiV1ChannelsKick($post_api_v1_channels_kick_request = null, string $contentType = self::contentTypes['postApiV1ChannelsKick'][0])
    {
        list($response) = $this->postApiV1ChannelsKickWithHttpInfo($post_api_v1_channels_kick_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsKickWithHttpInfo
     *
     * Remove User from Channel
     *
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsKickRequest $post_api_v1_channels_kick_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsKick'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsKickWithHttpInfo($post_api_v1_channels_kick_request = null, string $contentType = self::contentTypes['postApiV1ChannelsKick'][0])
    {
        $request = $this->postApiV1ChannelsKickRequest($post_api_v1_channels_kick_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsKickAsync
     *
     * Remove User from Channel
     *
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsKickRequest $post_api_v1_channels_kick_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsKick'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsKickAsync($post_api_v1_channels_kick_request = null, string $contentType = self::contentTypes['postApiV1ChannelsKick'][0])
    {
        return $this->postApiV1ChannelsKickAsyncWithHttpInfo($post_api_v1_channels_kick_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsKickAsyncWithHttpInfo
     *
     * Remove User from Channel
     *
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsKickRequest $post_api_v1_channels_kick_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsKick'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsKickAsyncWithHttpInfo($post_api_v1_channels_kick_request = null, string $contentType = self::contentTypes['postApiV1ChannelsKick'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddAll200Response';
        $request = $this->postApiV1ChannelsKickRequest($post_api_v1_channels_kick_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsKick'
     *
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsKickRequest $post_api_v1_channels_kick_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsKick'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsKickRequest($post_api_v1_channels_kick_request = null, string $contentType = self::contentTypes['postApiV1ChannelsKick'][0])
    {



        $resourcePath = '/api/v1/channels.kick';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_kick_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_kick_request));
            } else {
                $httpBody = $post_api_v1_channels_kick_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsLeave
     *
     * Leave  Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsLeaveRequest $post_api_v1_channels_leave_request post_api_v1_channels_leave_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsLeave'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsLeave200Response
     */
    public function postApiV1ChannelsLeave($x_auth_token, $x_user_id, $post_api_v1_channels_leave_request = null, string $contentType = self::contentTypes['postApiV1ChannelsLeave'][0])
    {
        list($response) = $this->postApiV1ChannelsLeaveWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_leave_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsLeaveWithHttpInfo
     *
     * Leave  Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsLeaveRequest $post_api_v1_channels_leave_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsLeave'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsLeave200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsLeaveWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_leave_request = null, string $contentType = self::contentTypes['postApiV1ChannelsLeave'][0])
    {
        $request = $this->postApiV1ChannelsLeaveRequest($x_auth_token, $x_user_id, $post_api_v1_channels_leave_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsLeave200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsLeave200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsLeave200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsLeave200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsLeave200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsLeaveAsync
     *
     * Leave  Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsLeaveRequest $post_api_v1_channels_leave_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsLeave'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsLeaveAsync($x_auth_token, $x_user_id, $post_api_v1_channels_leave_request = null, string $contentType = self::contentTypes['postApiV1ChannelsLeave'][0])
    {
        return $this->postApiV1ChannelsLeaveAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_leave_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsLeaveAsyncWithHttpInfo
     *
     * Leave  Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsLeaveRequest $post_api_v1_channels_leave_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsLeave'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsLeaveAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_leave_request = null, string $contentType = self::contentTypes['postApiV1ChannelsLeave'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsLeave200Response';
        $request = $this->postApiV1ChannelsLeaveRequest($x_auth_token, $x_user_id, $post_api_v1_channels_leave_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsLeave'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsLeaveRequest $post_api_v1_channels_leave_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsLeave'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsLeaveRequest($x_auth_token, $x_user_id, $post_api_v1_channels_leave_request = null, string $contentType = self::contentTypes['postApiV1ChannelsLeave'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsLeave'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsLeave'
            );
        }



        $resourcePath = '/api/v1/channels.leave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_leave_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_leave_request));
            } else {
                $httpBody = $post_api_v1_channels_leave_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsOpen
     *
     * Add Channel to User List
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsOpenRequest $post_api_v1_channels_open_request post_api_v1_channels_open_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsOpen'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response
     */
    public function postApiV1ChannelsOpen($x_auth_token, $x_user_id, $post_api_v1_channels_open_request = null, string $contentType = self::contentTypes['postApiV1ChannelsOpen'][0])
    {
        list($response) = $this->postApiV1ChannelsOpenWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_open_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsOpenWithHttpInfo
     *
     * Add Channel to User List
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsOpenRequest $post_api_v1_channels_open_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsOpen'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsOpenWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_open_request = null, string $contentType = self::contentTypes['postApiV1ChannelsOpen'][0])
    {
        $request = $this->postApiV1ChannelsOpenRequest($x_auth_token, $x_user_id, $post_api_v1_channels_open_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsOpenAsync
     *
     * Add Channel to User List
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsOpenRequest $post_api_v1_channels_open_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsOpen'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsOpenAsync($x_auth_token, $x_user_id, $post_api_v1_channels_open_request = null, string $contentType = self::contentTypes['postApiV1ChannelsOpen'][0])
    {
        return $this->postApiV1ChannelsOpenAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_open_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsOpenAsyncWithHttpInfo
     *
     * Add Channel to User List
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsOpenRequest $post_api_v1_channels_open_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsOpen'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsOpenAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_open_request = null, string $contentType = self::contentTypes['postApiV1ChannelsOpen'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
        $request = $this->postApiV1ChannelsOpenRequest($x_auth_token, $x_user_id, $post_api_v1_channels_open_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsOpen'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsOpenRequest $post_api_v1_channels_open_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsOpen'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsOpenRequest($x_auth_token, $x_user_id, $post_api_v1_channels_open_request = null, string $contentType = self::contentTypes['postApiV1ChannelsOpen'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsOpen'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsOpen'
            );
        }



        $resourcePath = '/api/v1/channels.open';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_open_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_open_request));
            } else {
                $httpBody = $post_api_v1_channels_open_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsRemoveLeader
     *
     * Remove Channel  Leader
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsRemoveLeaderRequest $post_api_v1_channels_remove_leader_request post_api_v1_channels_remove_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsRemoveLeader'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsRemoveLeader($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsRemoveLeader'][0])
    {
        list($response) = $this->postApiV1ChannelsRemoveLeaderWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsRemoveLeaderWithHttpInfo
     *
     * Remove Channel  Leader
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsRemoveLeaderRequest $post_api_v1_channels_remove_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsRemoveLeader'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsRemoveLeaderWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsRemoveLeader'][0])
    {
        $request = $this->postApiV1ChannelsRemoveLeaderRequest($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsRemoveLeaderAsync
     *
     * Remove Channel  Leader
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsRemoveLeaderRequest $post_api_v1_channels_remove_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsRemoveLeader'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsRemoveLeaderAsync($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsRemoveLeader'][0])
    {
        return $this->postApiV1ChannelsRemoveLeaderAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsRemoveLeaderAsyncWithHttpInfo
     *
     * Remove Channel  Leader
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsRemoveLeaderRequest $post_api_v1_channels_remove_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsRemoveLeader'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsRemoveLeaderAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsRemoveLeader'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
        $request = $this->postApiV1ChannelsRemoveLeaderRequest($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsRemoveLeader'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsRemoveLeaderRequest $post_api_v1_channels_remove_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsRemoveLeader'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsRemoveLeaderRequest($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsRemoveLeader'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsRemoveLeader'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsRemoveLeader'
            );
        }



        $resourcePath = '/api/v1/channels.removeLeader';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_remove_leader_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_remove_leader_request));
            } else {
                $httpBody = $post_api_v1_channels_remove_leader_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsRemoveModerator
     *
     * Remove Channel Moderator
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsRemoveLeaderRequest $post_api_v1_channels_remove_leader_request post_api_v1_channels_remove_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsRemoveModerator'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwner400Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsRemoveModerator($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsRemoveModerator'][0])
    {
        list($response) = $this->postApiV1ChannelsRemoveModeratorWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsRemoveModeratorWithHttpInfo
     *
     * Remove Channel Moderator
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsRemoveLeaderRequest $post_api_v1_channels_remove_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsRemoveModerator'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwner400Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsRemoveModeratorWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsRemoveModerator'][0])
    {
        $request = $this->postApiV1ChannelsRemoveModeratorRequest($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwner400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwner400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwner400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddOwner400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsRemoveModeratorAsync
     *
     * Remove Channel Moderator
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsRemoveLeaderRequest $post_api_v1_channels_remove_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsRemoveModerator'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsRemoveModeratorAsync($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsRemoveModerator'][0])
    {
        return $this->postApiV1ChannelsRemoveModeratorAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsRemoveModeratorAsyncWithHttpInfo
     *
     * Remove Channel Moderator
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsRemoveLeaderRequest $post_api_v1_channels_remove_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsRemoveModerator'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsRemoveModeratorAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsRemoveModerator'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
        $request = $this->postApiV1ChannelsRemoveModeratorRequest($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsRemoveModerator'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsRemoveLeaderRequest $post_api_v1_channels_remove_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsRemoveModerator'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsRemoveModeratorRequest($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsRemoveModerator'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsRemoveModerator'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsRemoveModerator'
            );
        }



        $resourcePath = '/api/v1/channels.removeModerator';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_remove_leader_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_remove_leader_request));
            } else {
                $httpBody = $post_api_v1_channels_remove_leader_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsRemoveOwner
     *
     * Remove Channel Owner
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsRemoveLeaderRequest $post_api_v1_channels_remove_leader_request post_api_v1_channels_remove_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsRemoveOwner'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsRemoveOwner($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsRemoveOwner'][0])
    {
        list($response) = $this->postApiV1ChannelsRemoveOwnerWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsRemoveOwnerWithHttpInfo
     *
     * Remove Channel Owner
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsRemoveLeaderRequest $post_api_v1_channels_remove_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsRemoveOwner'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsRemoveOwnerWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsRemoveOwner'][0])
    {
        $request = $this->postApiV1ChannelsRemoveOwnerRequest($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsRemoveOwnerAsync
     *
     * Remove Channel Owner
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsRemoveLeaderRequest $post_api_v1_channels_remove_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsRemoveOwner'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsRemoveOwnerAsync($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsRemoveOwner'][0])
    {
        return $this->postApiV1ChannelsRemoveOwnerAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsRemoveOwnerAsyncWithHttpInfo
     *
     * Remove Channel Owner
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsRemoveLeaderRequest $post_api_v1_channels_remove_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsRemoveOwner'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsRemoveOwnerAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsRemoveOwner'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
        $request = $this->postApiV1ChannelsRemoveOwnerRequest($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsRemoveOwner'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsRemoveLeaderRequest $post_api_v1_channels_remove_leader_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsRemoveOwner'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsRemoveOwnerRequest($x_auth_token, $x_user_id, $post_api_v1_channels_remove_leader_request = null, string $contentType = self::contentTypes['postApiV1ChannelsRemoveOwner'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsRemoveOwner'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsRemoveOwner'
            );
        }



        $resourcePath = '/api/v1/channels.removeOwner';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_remove_leader_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_remove_leader_request));
            } else {
                $httpBody = $post_api_v1_channels_remove_leader_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetAnnouncement
     *
     * Set Channel Announcement
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetAnnouncementRequest $post_api_v1_channels_set_announcement_request post_api_v1_channels_set_announcement_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetAnnouncement'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsSetAnnouncement200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsSetAnnouncement($x_user_id, $x_auth_token, $post_api_v1_channels_set_announcement_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetAnnouncement'][0])
    {
        list($response) = $this->postApiV1ChannelsSetAnnouncementWithHttpInfo($x_user_id, $x_auth_token, $post_api_v1_channels_set_announcement_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetAnnouncementWithHttpInfo
     *
     * Set Channel Announcement
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetAnnouncementRequest $post_api_v1_channels_set_announcement_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetAnnouncement'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsSetAnnouncement200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetAnnouncementWithHttpInfo($x_user_id, $x_auth_token, $post_api_v1_channels_set_announcement_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetAnnouncement'][0])
    {
        $request = $this->postApiV1ChannelsSetAnnouncementRequest($x_user_id, $x_auth_token, $post_api_v1_channels_set_announcement_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetAnnouncement200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetAnnouncement200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetAnnouncement200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetAnnouncement200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetAnnouncement200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetAnnouncementAsync
     *
     * Set Channel Announcement
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetAnnouncementRequest $post_api_v1_channels_set_announcement_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetAnnouncement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetAnnouncementAsync($x_user_id, $x_auth_token, $post_api_v1_channels_set_announcement_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetAnnouncement'][0])
    {
        return $this->postApiV1ChannelsSetAnnouncementAsyncWithHttpInfo($x_user_id, $x_auth_token, $post_api_v1_channels_set_announcement_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetAnnouncementAsyncWithHttpInfo
     *
     * Set Channel Announcement
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetAnnouncementRequest $post_api_v1_channels_set_announcement_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetAnnouncement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetAnnouncementAsyncWithHttpInfo($x_user_id, $x_auth_token, $post_api_v1_channels_set_announcement_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetAnnouncement'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetAnnouncement200Response';
        $request = $this->postApiV1ChannelsSetAnnouncementRequest($x_user_id, $x_auth_token, $post_api_v1_channels_set_announcement_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetAnnouncement'
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetAnnouncementRequest $post_api_v1_channels_set_announcement_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetAnnouncement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsSetAnnouncementRequest($x_user_id, $x_auth_token, $post_api_v1_channels_set_announcement_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetAnnouncement'][0])
    {

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetAnnouncement'
            );
        }

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetAnnouncement'
            );
        }



        $resourcePath = '/api/v1/channels.setAnnouncement';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_set_announcement_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_set_announcement_request));
            } else {
                $httpBody = $post_api_v1_channels_set_announcement_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetCustomFields
     *
     * Set Channel Custom Fields
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetCustomFieldsRequest $post_api_v1_channels_set_custom_fields_request post_api_v1_channels_set_custom_fields_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetCustomFields'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsSetCustomFields200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsSetCustomFields($x_user_id, $x_auth_token, $post_api_v1_channels_set_custom_fields_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetCustomFields'][0])
    {
        list($response) = $this->postApiV1ChannelsSetCustomFieldsWithHttpInfo($x_user_id, $x_auth_token, $post_api_v1_channels_set_custom_fields_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetCustomFieldsWithHttpInfo
     *
     * Set Channel Custom Fields
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetCustomFieldsRequest $post_api_v1_channels_set_custom_fields_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetCustomFields'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsSetCustomFields200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetCustomFieldsWithHttpInfo($x_user_id, $x_auth_token, $post_api_v1_channels_set_custom_fields_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetCustomFields'][0])
    {
        $request = $this->postApiV1ChannelsSetCustomFieldsRequest($x_user_id, $x_auth_token, $post_api_v1_channels_set_custom_fields_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetCustomFields200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetCustomFields200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetCustomFields200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetCustomFields200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetCustomFields200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetCustomFieldsAsync
     *
     * Set Channel Custom Fields
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetCustomFieldsRequest $post_api_v1_channels_set_custom_fields_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetCustomFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetCustomFieldsAsync($x_user_id, $x_auth_token, $post_api_v1_channels_set_custom_fields_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetCustomFields'][0])
    {
        return $this->postApiV1ChannelsSetCustomFieldsAsyncWithHttpInfo($x_user_id, $x_auth_token, $post_api_v1_channels_set_custom_fields_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetCustomFieldsAsyncWithHttpInfo
     *
     * Set Channel Custom Fields
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetCustomFieldsRequest $post_api_v1_channels_set_custom_fields_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetCustomFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetCustomFieldsAsyncWithHttpInfo($x_user_id, $x_auth_token, $post_api_v1_channels_set_custom_fields_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetCustomFields'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetCustomFields200Response';
        $request = $this->postApiV1ChannelsSetCustomFieldsRequest($x_user_id, $x_auth_token, $post_api_v1_channels_set_custom_fields_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetCustomFields'
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetCustomFieldsRequest $post_api_v1_channels_set_custom_fields_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetCustomFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsSetCustomFieldsRequest($x_user_id, $x_auth_token, $post_api_v1_channels_set_custom_fields_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetCustomFields'][0])
    {

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetCustomFields'
            );
        }

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetCustomFields'
            );
        }



        $resourcePath = '/api/v1/channels.setCustomFields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_set_custom_fields_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_set_custom_fields_request));
            } else {
                $httpBody = $post_api_v1_channels_set_custom_fields_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetDefault
     *
     * Set Default Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetDefaultRequest $post_api_v1_channels_set_default_request post_api_v1_channels_set_default_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetDefault'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsSetDefault200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsSetDefault($x_auth_token, $x_user_id, $post_api_v1_channels_set_default_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetDefault'][0])
    {
        list($response) = $this->postApiV1ChannelsSetDefaultWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_default_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetDefaultWithHttpInfo
     *
     * Set Default Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetDefaultRequest $post_api_v1_channels_set_default_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetDefault'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsSetDefault200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetDefaultWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_default_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetDefault'][0])
    {
        $request = $this->postApiV1ChannelsSetDefaultRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_default_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetDefault200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetDefault200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetDefault200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetDefault200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetDefault200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetDefaultAsync
     *
     * Set Default Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetDefaultRequest $post_api_v1_channels_set_default_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetDefault'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetDefaultAsync($x_auth_token, $x_user_id, $post_api_v1_channels_set_default_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetDefault'][0])
    {
        return $this->postApiV1ChannelsSetDefaultAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_default_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetDefaultAsyncWithHttpInfo
     *
     * Set Default Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetDefaultRequest $post_api_v1_channels_set_default_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetDefault'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetDefaultAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_default_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetDefault'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetDefault200Response';
        $request = $this->postApiV1ChannelsSetDefaultRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_default_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetDefault'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetDefaultRequest $post_api_v1_channels_set_default_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetDefault'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsSetDefaultRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_default_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetDefault'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetDefault'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetDefault'
            );
        }



        $resourcePath = '/api/v1/channels.setDefault';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_set_default_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_set_default_request));
            } else {
                $httpBody = $post_api_v1_channels_set_default_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetDescription
     *
     * Set Channel Description
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetDescriptionRequest $post_api_v1_channels_set_description_request  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetDescription'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsSetDescription200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsSetDescription($x_auth_token, $x_user_id, $post_api_v1_channels_set_description_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetDescription'][0])
    {
        list($response) = $this->postApiV1ChannelsSetDescriptionWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_description_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetDescriptionWithHttpInfo
     *
     * Set Channel Description
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetDescriptionRequest $post_api_v1_channels_set_description_request  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetDescription'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsSetDescription200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetDescriptionWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_description_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetDescription'][0])
    {
        $request = $this->postApiV1ChannelsSetDescriptionRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_description_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetDescription200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetDescription200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetDescription200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetDescription200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetDescription200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetDescriptionAsync
     *
     * Set Channel Description
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetDescriptionRequest $post_api_v1_channels_set_description_request  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetDescription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetDescriptionAsync($x_auth_token, $x_user_id, $post_api_v1_channels_set_description_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetDescription'][0])
    {
        return $this->postApiV1ChannelsSetDescriptionAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_description_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetDescriptionAsyncWithHttpInfo
     *
     * Set Channel Description
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetDescriptionRequest $post_api_v1_channels_set_description_request  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetDescription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetDescriptionAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_description_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetDescription'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetDescription200Response';
        $request = $this->postApiV1ChannelsSetDescriptionRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_description_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetDescription'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetDescriptionRequest $post_api_v1_channels_set_description_request  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetDescription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsSetDescriptionRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_description_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetDescription'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetDescription'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetDescription'
            );
        }



        $resourcePath = '/api/v1/channels.setDescription';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_set_description_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_set_description_request));
            } else {
                $httpBody = $post_api_v1_channels_set_description_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetJoinCode
     *
     * Set Channel Join Code
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetJoinCodeRequest $post_api_v1_channels_set_join_code_request post_api_v1_channels_set_join_code_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetJoinCode'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsSetJoinCode200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsSetJoinCode($x_auth_token, $x_user_id, $post_api_v1_channels_set_join_code_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetJoinCode'][0])
    {
        list($response) = $this->postApiV1ChannelsSetJoinCodeWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_join_code_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetJoinCodeWithHttpInfo
     *
     * Set Channel Join Code
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetJoinCodeRequest $post_api_v1_channels_set_join_code_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetJoinCode'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsSetJoinCode200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetJoinCodeWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_join_code_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetJoinCode'][0])
    {
        $request = $this->postApiV1ChannelsSetJoinCodeRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_join_code_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetJoinCode200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetJoinCode200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetJoinCode200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetJoinCode200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetJoinCode200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetJoinCodeAsync
     *
     * Set Channel Join Code
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetJoinCodeRequest $post_api_v1_channels_set_join_code_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetJoinCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetJoinCodeAsync($x_auth_token, $x_user_id, $post_api_v1_channels_set_join_code_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetJoinCode'][0])
    {
        return $this->postApiV1ChannelsSetJoinCodeAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_join_code_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetJoinCodeAsyncWithHttpInfo
     *
     * Set Channel Join Code
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetJoinCodeRequest $post_api_v1_channels_set_join_code_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetJoinCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetJoinCodeAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_join_code_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetJoinCode'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetJoinCode200Response';
        $request = $this->postApiV1ChannelsSetJoinCodeRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_join_code_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetJoinCode'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetJoinCodeRequest $post_api_v1_channels_set_join_code_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetJoinCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsSetJoinCodeRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_join_code_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetJoinCode'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetJoinCode'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetJoinCode'
            );
        }



        $resourcePath = '/api/v1/channels.setJoinCode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_set_join_code_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_set_join_code_request));
            } else {
                $httpBody = $post_api_v1_channels_set_join_code_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetPurpose
     *
     * Set Channel Purpose
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetPurposeRequest $post_api_v1_channels_set_purpose_request post_api_v1_channels_set_purpose_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetPurpose'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsSetPurpose200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsSetPurpose($x_auth_token, $x_user_id, $post_api_v1_channels_set_purpose_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetPurpose'][0])
    {
        list($response) = $this->postApiV1ChannelsSetPurposeWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_purpose_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetPurposeWithHttpInfo
     *
     * Set Channel Purpose
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetPurposeRequest $post_api_v1_channels_set_purpose_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetPurpose'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsSetPurpose200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetPurposeWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_purpose_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetPurpose'][0])
    {
        $request = $this->postApiV1ChannelsSetPurposeRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_purpose_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetPurpose200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetPurpose200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetPurpose200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetPurpose200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetPurpose200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetPurposeAsync
     *
     * Set Channel Purpose
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetPurposeRequest $post_api_v1_channels_set_purpose_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetPurpose'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetPurposeAsync($x_auth_token, $x_user_id, $post_api_v1_channels_set_purpose_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetPurpose'][0])
    {
        return $this->postApiV1ChannelsSetPurposeAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_purpose_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetPurposeAsyncWithHttpInfo
     *
     * Set Channel Purpose
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetPurposeRequest $post_api_v1_channels_set_purpose_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetPurpose'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetPurposeAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_purpose_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetPurpose'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetPurpose200Response';
        $request = $this->postApiV1ChannelsSetPurposeRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_purpose_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetPurpose'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetPurposeRequest $post_api_v1_channels_set_purpose_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetPurpose'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsSetPurposeRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_purpose_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetPurpose'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetPurpose'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetPurpose'
            );
        }



        $resourcePath = '/api/v1/channels.setPurpose';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_set_purpose_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_set_purpose_request));
            } else {
                $httpBody = $post_api_v1_channels_set_purpose_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetReadOnly
     *
     * Set Channel ReadOnly
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnlyRequest $post_api_v1_channels_set_read_only_request post_api_v1_channels_set_read_only_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetReadOnly'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnly200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsSetReadOnly($x_auth_token, $x_user_id, $post_api_v1_channels_set_read_only_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetReadOnly'][0])
    {
        list($response) = $this->postApiV1ChannelsSetReadOnlyWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_read_only_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetReadOnlyWithHttpInfo
     *
     * Set Channel ReadOnly
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnlyRequest $post_api_v1_channels_set_read_only_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetReadOnly'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnly200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetReadOnlyWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_read_only_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetReadOnly'][0])
    {
        $request = $this->postApiV1ChannelsSetReadOnlyRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_read_only_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnly200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnly200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnly200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnly200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnly200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetReadOnlyAsync
     *
     * Set Channel ReadOnly
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnlyRequest $post_api_v1_channels_set_read_only_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetReadOnly'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetReadOnlyAsync($x_auth_token, $x_user_id, $post_api_v1_channels_set_read_only_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetReadOnly'][0])
    {
        return $this->postApiV1ChannelsSetReadOnlyAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_read_only_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetReadOnlyAsyncWithHttpInfo
     *
     * Set Channel ReadOnly
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnlyRequest $post_api_v1_channels_set_read_only_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetReadOnly'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetReadOnlyAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_read_only_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetReadOnly'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnly200Response';
        $request = $this->postApiV1ChannelsSetReadOnlyRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_read_only_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetReadOnly'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnlyRequest $post_api_v1_channels_set_read_only_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetReadOnly'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsSetReadOnlyRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_read_only_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetReadOnly'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetReadOnly'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetReadOnly'
            );
        }



        $resourcePath = '/api/v1/channels.setReadOnly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_set_read_only_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_set_read_only_request));
            } else {
                $httpBody = $post_api_v1_channels_set_read_only_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetTopic
     *
     * Set Channel Topic
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetTopicRequest $post_api_v1_channels_set_topic_request post_api_v1_channels_set_topic_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetTopic'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsSetTopic200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsSetTopic($x_auth_token, $x_user_id, $post_api_v1_channels_set_topic_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetTopic'][0])
    {
        list($response) = $this->postApiV1ChannelsSetTopicWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_topic_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetTopicWithHttpInfo
     *
     * Set Channel Topic
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetTopicRequest $post_api_v1_channels_set_topic_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetTopic'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsSetTopic200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetTopicWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_topic_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetTopic'][0])
    {
        $request = $this->postApiV1ChannelsSetTopicRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_topic_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetTopic200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetTopic200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetTopic200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetTopic200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetTopic200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetTopicAsync
     *
     * Set Channel Topic
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetTopicRequest $post_api_v1_channels_set_topic_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetTopicAsync($x_auth_token, $x_user_id, $post_api_v1_channels_set_topic_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetTopic'][0])
    {
        return $this->postApiV1ChannelsSetTopicAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_topic_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetTopicAsyncWithHttpInfo
     *
     * Set Channel Topic
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetTopicRequest $post_api_v1_channels_set_topic_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetTopicAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_topic_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetTopic'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetTopic200Response';
        $request = $this->postApiV1ChannelsSetTopicRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_topic_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetTopic'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetTopicRequest $post_api_v1_channels_set_topic_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsSetTopicRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_topic_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetTopic'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetTopic'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetTopic'
            );
        }



        $resourcePath = '/api/v1/channels.setTopic';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_set_topic_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_set_topic_request));
            } else {
                $httpBody = $post_api_v1_channels_set_topic_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetType
     *
     * Set Channel Type
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetTypeRequest $post_api_v1_channels_set_type_request  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetType'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnly200Response
     */
    public function postApiV1ChannelsSetType($x_auth_token, $x_user_id, $post_api_v1_channels_set_type_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetType'][0])
    {
        list($response) = $this->postApiV1ChannelsSetTypeWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_type_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetTypeWithHttpInfo
     *
     * Set Channel Type
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetTypeRequest $post_api_v1_channels_set_type_request  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetType'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnly200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetTypeWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_type_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetType'][0])
    {
        $request = $this->postApiV1ChannelsSetTypeRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_type_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnly200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnly200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnly200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnly200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnly200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetTypeAsync
     *
     * Set Channel Type
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetTypeRequest $post_api_v1_channels_set_type_request  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetTypeAsync($x_auth_token, $x_user_id, $post_api_v1_channels_set_type_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetType'][0])
    {
        return $this->postApiV1ChannelsSetTypeAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_type_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetTypeAsyncWithHttpInfo
     *
     * Set Channel Type
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetTypeRequest $post_api_v1_channels_set_type_request  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetTypeAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_set_type_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetType'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsSetReadOnly200Response';
        $request = $this->postApiV1ChannelsSetTypeRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_type_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetType'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsSetTypeRequest $post_api_v1_channels_set_type_request  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsSetType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsSetTypeRequest($x_auth_token, $x_user_id, $post_api_v1_channels_set_type_request = null, string $contentType = self::contentTypes['postApiV1ChannelsSetType'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetType'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetType'
            );
        }



        $resourcePath = '/api/v1/channels.setType';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_set_type_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_set_type_request));
            } else {
                $httpBody = $post_api_v1_channels_set_type_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsUnarchive
     *
     * Unarchive a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsUnarchiveRequest $post_api_v1_channels_unarchive_request post_api_v1_channels_unarchive_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsUnarchive'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response
     */
    public function postApiV1ChannelsUnarchive($x_auth_token, $x_user_id, $post_api_v1_channels_unarchive_request = null, string $contentType = self::contentTypes['postApiV1ChannelsUnarchive'][0])
    {
        list($response) = $this->postApiV1ChannelsUnarchiveWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_unarchive_request, $contentType);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsUnarchiveWithHttpInfo
     *
     * Unarchive a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsUnarchiveRequest $post_api_v1_channels_unarchive_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsUnarchive'] to see the possible values for this operation
     *
     * @throws \RocketChatRoomsApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response|\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsUnarchiveWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_unarchive_request = null, string $contentType = self::contentTypes['postApiV1ChannelsUnarchive'][0])
    {
        $request = $this->postApiV1ChannelsUnarchiveRequest($x_auth_token, $x_user_id, $post_api_v1_channels_unarchive_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RocketChatRoomsApi\Model\PostApiV1ChannelsCreate401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsUnarchiveAsync
     *
     * Unarchive a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsUnarchiveRequest $post_api_v1_channels_unarchive_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsUnarchive'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsUnarchiveAsync($x_auth_token, $x_user_id, $post_api_v1_channels_unarchive_request = null, string $contentType = self::contentTypes['postApiV1ChannelsUnarchive'][0])
    {
        return $this->postApiV1ChannelsUnarchiveAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_unarchive_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsUnarchiveAsyncWithHttpInfo
     *
     * Unarchive a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsUnarchiveRequest $post_api_v1_channels_unarchive_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsUnarchive'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsUnarchiveAsyncWithHttpInfo($x_auth_token, $x_user_id, $post_api_v1_channels_unarchive_request = null, string $contentType = self::contentTypes['postApiV1ChannelsUnarchive'][0])
    {
        $returnType = '\RocketChatRoomsApi\Model\PostApiV1ChannelsAddLeader200Response';
        $request = $this->postApiV1ChannelsUnarchiveRequest($x_auth_token, $x_user_id, $post_api_v1_channels_unarchive_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsUnarchive'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \RocketChatRoomsApi\Model\PostApiV1ChannelsUnarchiveRequest $post_api_v1_channels_unarchive_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postApiV1ChannelsUnarchive'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postApiV1ChannelsUnarchiveRequest($x_auth_token, $x_user_id, $post_api_v1_channels_unarchive_request = null, string $contentType = self::contentTypes['postApiV1ChannelsUnarchive'][0])
    {

        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsUnarchive'
            );
        }

        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsUnarchive'
            );
        }



        $resourcePath = '/api/v1/channels.unarchive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_api_v1_channels_unarchive_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_api_v1_channels_unarchive_request));
            } else {
                $httpBody = $post_api_v1_channels_unarchive_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
